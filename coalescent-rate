# Coalescence theory

A simple python code to demonstrate probability of coalescence using a simple simulation of Kingman’s coalescent process.

```python
import numpy as np
import matplotlib.pyplot as plt

#### Algorithm 1
n = 50 # Number of tmax
N = 5 # Population size
tmax = list(range(n))
new_internal_node = n

# Initialise
k = n
waiting_times = []
coalescent_events = []
current_time = 0.0
node_times = {i: 0.0 for i in tmax}  # Time = 0 for all leaves
tree = {}  # Dictionary to store tree: key = node, value = (child1, child2)
tmax = list(range(n))
new_internal_node = n

def func(tmax, N):
    p = {}
    for t in range(1, (max(tmax) + 1)):
        p[t] = (1 - (1 / (2*N)))**(t-1) * (1 / (2*N))
    return p

pt = func(tmax, N)

# Extract keys and values properly
t = list(pt.keys())
p = list(pt.values())

# Plot
plt.plot(t, p, marker='o', linestyle='-')
plt.xlabel("t (generations)")
plt.ylabel("p(t)")
plt.title("Probability of Coalescence at Generation t")
plt.grid(True)
plt.show()

while k > 1:
    # Coalescent rate
    lambdak = (k * (k - 1)) / (4 * N)
    # Sample waiting time
    sample_w_t = np.random.exponential(scale=1/lambdak, size=10)
    waiting_times.append(sample_w_t[0])
    current_time += sample_w_t[0]
    # Choose 2 tmax to coalesce
    pair = np.random.choice(tmax, size=2, replace=False)
    
    tree[new_internal_node] = tuple[pair]
    node_times[new_internal_node] = current_time
    coalescent_events.append((pair[0], pair[1], new_internal_node, current_time))


    # Remove coalesced tmax and add new internal node
    tmax = [l for l in tmax if l not in pair]
    tmax.append(new_internal_node)
    new_internal_node += 1
    k -= 1

    print(f"Waiting time for k={k}: {sample_w_t[0]:.4f}")
    print(f"Coalescing: {pair[0]} and {pair[1]} → new node {new_internal_node}")

# Root node is the final lineage
root = tmax[0]
print(f"\nFinal root node: {root} at time {node_times[root]:.4f}")

import matplotlib.pyplot as plt

coalescent_times = np.cumsum(waiting_times[::-1])  # Oldest at top

plt.plot(range(2, n + 1), coalescent_times, marker='o', linestyle = '-')
plt.xlabel("Number of tmax (k)")
plt.ylabel("Time")
plt.title("Coalescent Tree Time Steps")
plt.gca().invert_yaxis()  # So root (MRCA) is at the top
plt.show()
```

The below plot shows the geometric (discrete exponential) distribution of probabilities, ```p(t)```, over ```t``` generations 
(probabilitiy denoted as pt in the code). It represents the probability that two tmax coalesce exactly at generation 
```t``` back to their most recent common ancestor (MRCA). 

<img src="coalescence_probabilities.png" alt="Alt text" width="100">




