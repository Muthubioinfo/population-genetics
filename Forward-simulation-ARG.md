
# Forward-Time Simulation with Ancestral Recombination Graph (ARG) using Tskit

This shows how to simulate forward-time ancestry using discrete-time Wright-Fisher model and visualize it with tskit tables. The simulation shows the full Ancestral Recombination Graph (ARG) by tracking inheritance across generations, assuming (1) without recombination, and (2) with recombination. The following example is recreated from tskit tutorial on [Building a forward simulator](https://tskit.dev/tutorials/forward_sims.html).


## Wright-Fisher Model

Basic assumptions of Wright-Fisher:
* A constant population of size N diploid individuals.
* Generations are non-overlapping (population emerged from previous generations, and do not coexist in time)
* Each succesive generation is formed by random mating from the previous one.

Consider a simulation of diploid individuals. Each chromosome is inherited from a parent chromosome in the previous generation, and assuming recombination can optionally occur during inheritance.

In python, first initialize tskit and assign variable for population size (L).

```python
import tskit
import numpy as np

random_seed = 2
random = np.random.default_rng(random_seed)
L = 50000 #Population of 50,000 individuals

# For visualising unsimplified tree sequences, it can help to flag all nodes as samples
default_node_flags = tskit.NODE_IS_SAMPLE

```

### Create a new diploid individual 
Assuming each individual in the population carries a diploid genome. Hence, define a function to add a diploid individual to the population and return assign node IDs.

```python
def make_diploid(tables, time, parent_individual) -> tuple[int, tuple[int, int]]:
    individual_id = tables.individual.add.row(parent_individual)
    return individual_id, (
        tables.nodes.add.row(default_node_flags, time, individual=individual_id),
        tables.nodes.add.row(default_node_flags, time, individual=individual_id)
    )
```

### Inheritance without recombination
Each child inherits one chromosome from one of the parent’s chromosomes (randomly chosen).
```python
def add_inheritance_paths(tables, parent_nodes, child_node, recombination_rate):
    "Add inheritance paths from a randomly chosen parent genome to the child genome."
    assert recombination_rate == 0
    left, right = [20_000, 21_000]  # only define inheritance in this focal region
    inherit_from = random.integers(2)  # randomly choose the 1st or the 2nd parent node
    tables.edges.add_row(left, right, parent_nodes[inherit_from], child_node)
```

### Inheritance with recombination
This function simulates recombination by choosing breakpoints and switching the inherited parent chromosome at each breakpoint.

```python3
def add_inheritance_paths_recomb(tables, parent_genomes, child_genome, recombination_rate):
    "Add paths from parent genomes to the child genome, with crossover recombination."
    L = tables.sequence_length
    num_recombinations = random.poisson(recombination_rate * L)
    breakpoints = random.uniform(0, L, size=num_recombinations)
    breakpoints = np.concatenate(([0], np.unique(breakpoints), [L]))
    inherit_from = random.integers(2)  # starting parental genome

    # iterate over pairs of ([0, b1], [b1, b2], [b2, b3], ... [bN, L])
    for left, right in zip(breakpoints[:-1], breakpoints[1:]):
        tables.edges.add_row(
            left, right, parent_genomes[inherit_from], child_genome)
        inherit_from = 1 - inherit_from  # switch to other parent genome
```

### 👨‍👩‍👧 Generate New Generation (Wright-Fisher Step)
A new generation is generated by:
*Choosing two parents (can be the same, i.e., selfing allowed).
*Creating a new diploid individual (child).
*Adding edges to trace which chromosome came from which parent.


```python 3
def new_population(tables, time, prev_pop, recombination_rate) -> dict[int, tuple[int, int]]:
    pop = {}  # fill with individual_ID: (maternal_genome_ID, paternal_genome_ID)
    prev_individuals = np.array([i for i in prev_pop.keys()], dtype=np.int32)

    for _ in range(len(prev_pop)):
        mother_and_father = random.choice(prev_individuals, 2, replace=True) 
        child_id, child_genomes = make_diploid(tables, time, mother_and_father)
        pop[child_id] = child_genomes  # store the genome IDs

    for child_genome, parent_individual in zip(child_genomes, mother_and_father):
            parent_genomes = prev_pop[parent_individual]
            add_inheritance_paths(tables, parent_genomes, child_genome, recombination_rate)
    return pop
```

🔄 Start Initial Population
This function creates the founder generation or initial/present population.

```python3
def initialise_population(tables, time, size) -> dict[int, tuple[int, int]]:
    # Just return a dictionary by repeating step 2 above
    return dict(make_diploid(tables, time) for _ in range(size))
```

🧪 What’s Next?
These functions used to:
*Simulate multiple generations
*Track recombination across generations
*Visualize the resulting tree sequences using tskit

Example for usage:

```python
tables = tskit.TableCollection(sequence_length=50_000)
pop0 = initialise_population(tables, time=0, size=10)
pop1 = new_population(tables, time=1, prev_pop=pop0, recombination_rate=0)
```
Once all generations are simulated, you can simplify and save the tree sequence:

```python
ts = tables.tree_sequence()
ts = ts.simplify()
ts.dump("wf_forward_sim.trees")
```
